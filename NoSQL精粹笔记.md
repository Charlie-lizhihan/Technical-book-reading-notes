# 前言

本博客写于阅读完《NoSQL精粹》这本书之后，作为一篇读书笔记，想要了解NoSQL的朋友可以从这个博客里面整理一些知识，也希望熟练NoSQL的朋友读完也有收获

首先对NoSQL进行一个简单的介绍，最初的NoSQL表示的是“开源分布式的非关系型数据库”，但是NoSQL具体含义是什么并没有一个权威的定义，实际上大部分人的定义是“not only sql”，而并非是对sql说不，不用去纠结为什么不是NOSQL而是NoSQL，我们只需要理解NoSQL表示的是一般具有开源特征，不适用SQL，为了在集群中使用（不全是），一般不需要使用模式（不用事先修改结构定义即可自由添加字段）

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210909101216492.png" alt="image-20210909101216492" style="zoom:30%;" />



# 1. 为什么使用NoSQL

大多数NoSQL研发动机都是要在集群环境中运行，也有例外（图数据库）；需要在集群上（单个机器存储大数据不现实）运行大量数据，但是关系型数据库不能在集群中高效运行，这导致“混合持久化”的出现，也就是针对不同场景使用不同的数据存储方式。

选用NoSQL的主要原因：

1. 待处理的数据量很大，对数据访问的效率要求很高，从而必须把数据放在集群上
2. 采用一种更为方便的数据交互方式来提高应用程序开发效率

各种NoSQL数据库的共同特征：

1. 不使用关系模型
2. 在集群中运行良好
3. 开源
4. 无模式



NoSQL生态系统中广泛使用的模型：键值，文档，列族，图



# 2. 聚合数据模型

## 聚合

数据模型指数据库组织数据的方式，正式名称为“元模型”

聚合的概念可以通过下面的例子进行理解，客户和订单就是两个聚合。当然，这个数据库的设计还可以设计成一个聚合的形式，聚合的设计依赖于你想怎么操纵数据库

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210818154357558.png" alt="image-20210818154357558" style="zoom:50%;" />

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210818154409780.png" alt="image-20210818154409780" style="zoom:50%;" />

一般来说，面向聚合的数据库不支持跨越多个聚合的ACID事务（原子性，一致性，隔离性，持久性），它每次只能在一个聚合结构上执行原子性操作

聚合数据库在集群上管理数据存储更方便



## 键值数据模型和文档数据模型

这两种数据模型主要都通过聚合来创建，每个聚合中都有一个获取数据所用的键或ID。

键值数据库聚合不透明，不需要知道其中内部实现细节就可以为外部程序使用；文档数据库聚合可以看到其中结构。因此键值数据库可以在聚合中存储任意数据，文档数据库定义了其允许的结构和数据类型，，需要限制存放，但是访问数据更加灵活。

键值数据库依赖于键来搜索聚合内容；文档数据库提交的查询关键词往往基于文档的内部结构



## 列族存储

将这种存储方式视为两级聚合结构比较好理解，第一个键代表行标识符，可以用来获得想要的集合，每个行聚合本身又是一个映射；第二个键就是列，

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210818165941794.png" alt="image-20210818165941794" style="zoom:50%;" />

用更直观的hbase存储来看就是下面这样：

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210818170137592.png" alt="image-20210818170137592" style="zoom:50%;" />

所以有两种数据组织方式：

面向行：每一行都是一个聚合，聚合内部存有一些包含有用数据块的列族

面向列：每个列族都定义了一种记录类型，其中每行是一条记录



## 总结

这三种数据库都使用了聚合的概念，而且都拥有可以查找其内容的索引键，聚合也是”更新“操作的最小数据单位。

键值数据模型将聚合视为不透明的整体，只能根据键来查出整个集合；

文档数据模型对数据库透明，可以仅仅查询一部分聚合中的内容，但是数据库不好调整文档结构；

列族数据模型把聚合分为列族，让数据库将其视为行聚合内的一个数据单元，此类聚合的结构可以提高访问性



# 3. 数据模型详解

为了同时查找两个聚合中的内容，可能需要知道数据之间的关系，使用例如客户ID来进行分别查找，所以很多数据库都据此设计了索引，用户也可以查询这个内容。

面向聚合的数据库在操作多个聚合时显得相当笨拙，因为数据库只能保证单一聚合内部内容的原子性，如果一次更新多个聚合，就无法应对中途的错误。



## 图数据库

图数据库和聚合数据库的明显差异在于其重视数据间的关系，它大多运行在单一服务器上

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210818203334233.png" alt="image-20210818203334233" style="zoom:50%;" />

这种数据库适合处理例如 “查找我和我朋友都喜欢的作者写的数据库相关的书” 这种问题，图数据库一般会花较多时间用于插入关系数据，缩短遍历关系所需要的时间



## 各个数据模型的共同点：无模式

以上四种NoSQL数据库有个共同点就是它们都是无模式的，模式在关系型数据库中是指预定义结构向数据库说明：有哪些表格，哪些列，什么数据类型。

无模式的数据库在更改数据，删除数据，增添数据时十分简单，不仅不用考虑数据的存储类型，直接加入就好，删除时也不用考虑某一列的历史数据被删除

但是在编写数据访问程序的时候，就只能使用程序来指定某种“隐含模式”了，这是指对数据结构做的一系列假设，这又会导致多人共同编辑使用困难的问题；其他人想理解这其中的数据也很困难，需要理解程序

这样又会导致多人编辑出现问题，解决方法可以通过多人使用统一应用程序来进行数据库互动操作；将聚合中为不同应用程序明确划分区域；将文档分为不同的区段，将不同的列族分给不同的应用程序



## NoSQL的物化视图

关系数据库中的视图是指一张通过基表计算出来的表，数据库在访问的时候只需要计算视图中的数据，这是一种很方便的封装形式。

NoSQL没有视图的概念，只有物化视图的概念，这是一种预先算好并缓存在磁盘中的视图，预先计算查询操作的结果，将其缓存起来。在数据读取十分频繁，而且需要访问旧数据的情况下，物化视图效率很高。物化视图可以根据需求选择更新频率



## 构建数据存取模型

一般来收，构建不同形式的NoSQL支持的数据应用场景不同，不同的聚合策略也会影响到数据的查询效率。

例如将orderID放在customer键下，和将orderID与customer分别构建为聚合，这两种存储方式，后者的查询效率就会更高，因为第一种我如果想查询某个customer的某个orderID，会调出所有的order信息

图数据库应用在为用户推荐产品或者发掘用户的操作模式时效率更高



# 4. 分布式模型

相对于传统的购买服务器扩大数据库的方式，将数据库运行在服务器集群上的横向扩展方式更加适用，而数据分布有两条途径：复制，分片。复制又分为主从复制和对等复制

但是需要说明的是，如果可以在单一的服务器上使用NoSQL，我们都更愿意这么做，这对数据的开发管理来说都更容易



## 分片

分片就是将数据的各个部分存放在不同的服务器中，实现横向扩展，应该尽量保证每台服务器负载时均衡的

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210818230458660.png" alt="image-20210818230458660" style="zoom:50%;" />

分片可以同时提升写入和读取的效率，但是分片面对节点出错，并没有好处，仅仅能保证不经常访问这部分数据的用户不受影响。

在服务器能应付当前的数据量时不用分片，当是在需要的时候才去尝试这种方法，但是决定使用时，一定要尽早的准备好，否则产品上线后再去启用分片，会导致数据不可用



## 复制

### 主从复制

主从式分布中，我们要将数据复制到多个节点上，其中一个节点作为主节点，存放权威数据，通常负责处理数据更新操作；其他节点叫做从节点，复制主要实现从节点和主节点的同步

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210818230745562.png" alt="image-20210818230745562" style="zoom: 33%;" />

主从复制可以提升读取的性能，以及读取操作的故障恢复能力，但是就面对数据不一致性的问题，且对写入帮助不大，因为写入操作还是要依赖于主节点



## 对等复制

对等复制没有主节点的概念，所有副本地位相同，都可以接受写入请求，丢失一个副本也不会影响整个数据库的访问，这种方法还是会面对数据不一致的问题，难以保证同时在不同节点写入数据的更新问题

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210819100720260.png" alt="image-20210819100720260" style="zoom: 33%;" />



## 复制的分片的结合

主从复制和分片结合：整个系统有多个主节点，但是针对某项数据来说主节点只有一个；同一个节点既可以做某些数据的主节点，也可以做其他数据的从节点

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210819101958072.png" alt="image-20210819101958072" style="zoom:33%;" />

对等复制与分片的结合：可以将每个分片数据放在3格节点中，某个节点出错，它们上面保存的那些分片数据会由其他节点重建

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210819102532818.png" alt="image-20210819102532818" style="zoom:33%;" />



# 5. 一致性

## 更新一致性

这指的是两个人在同时更新数据导致的写冲突问题，解决方法包含悲观方式和乐观方式。

悲观方式指避免冲突，采用写入锁的方法保证写入顺序；这样遇到的问题是响应速度可能较低

乐观方式指让冲突发生然后再去解决，可以使用条件更新的方式，测试数据的当前值是否和上次读入的值相同；另外乐观方式还可以将两份更新都保存，交给程序员来进行冲突处理

为了保证更新操作的一致性，除了对等复制的模型，其他模型将针对某份数据的所有写入交给一个节点来完成，就很容易保证更新操作的一致性了



## 读取一致性

读取一致性的问题可能出现在数据库中的内容更新，但是两个不同的用户读取到的内容是不同的，因为两个用户访问的节点是不一样的，一个先更新一个后更新；还可能出现在两个数据要更新，但是用户读取时数据库仅仅更新好了其中一个，这样用户就会访问到错误的数据。



## 放宽一致性约束

有时为了其他性能是一定需要牺牲一致性来换取其他性能的。事务可以保证很强的一致性，但是对性能影响太大了，在引入分片后更是这样

想要取得较好的一致性，就要用许多节点来执行数据操作，这又会增大延迟，所以经常需要在一致性和延迟之间权衡



# 6. 版本戳

事务也有其存在弊端的时候，例如有时候有些更新操作无法封装在一个事务之内，这会导致事务打开时间过长，这些问题都可以用**版本戳**来解决，这个技术用来解决单服务器向多服务器迁移也很好

## 商业事务与系统事务

通常来说，用户交互操作（商业事务）之后，应用程序才会开始系统事务，但是如果在系统事务期间数据发生了改变，怎么办呢？（例如在刷卡支付中时，改变了送货地址，导致费用增加）

可以使用离线并发的技术，乐观离线锁就是这样的方法，客户端执行操作时，将重新读取商业事务所依赖的信息，并且检测该信息在首次读取后发生了变化没有，**版本戳**可以达到我们的目的

可以创建使用了计数器和内容哈希码的版本戳，正常来说比较计数器就可以查看新旧，但是遇到两个节点同时更新，我们仍可以使用哈希码来分辨



# 7. 映射-化简（mapreduce）

映射-化简模型，是一种安排数据处理流程的手段，可以利用集群中的多台计算机，同时又能将某台计算机所需的数据及处理工作尽量放在本机执行



## 映射化简与归并

基本的映射化简包含了两个函数，映射阶段每个节点进行各自的函数映射操作，化简阶段接受多个映射操作的输出作为其输入值，然后将之合并。下面的例子假设订单作为聚合单元，订单数量巨大，所以分片存储在多台主机中，计算多个商品的近7日销售总和，利用映射化简的方法的设计。

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908082950229.png" alt="image-20210908082950229" style="zoom:50%;" />

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908083001998.png" alt="image-20210908083001998" style="zoom:50%;" />

以上是一个最简单的映射化简任务，只有一个映射函数操作，将不同节点中所有的映射任务的输出连接起来并传递给化简函数即可，类似于下图的操作

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908085615238.png" alt="image-20210908085615238" style="zoom:50%;" />

然而我们还可以引入数据分区的概念，以增加处理并发的能力，如下图所示

![image-20210908085842434](/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908085842434.png)

在映射函数完成后，还可以加入一个归并操作，以减少映射到化简的数据传输量，归并操作只能是输入和输出形式相同的化简函数

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908090129853.png" alt="image-20210908090129853" style="zoom:50%;" />

## 组合映射化简

如果为了将某产品2011年每个月的销量与上一年同月份进行比较，可以使用两个映射化简来实现；两阶段映射化简还有个好处就是可以把输出的中间结果用于计算其他输出数据，进行复用，可以将这些数据放在数据库中，形成视图的概念。

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908091336969.png" alt="image-20210908091336969" style="zoom:50%;" />

映射化简如果组织成增量更新的方式可以降低计算量，映射部分基本都是这样，化简部分根据面对的情况不同而不同



# 实现

这部分详细阐述各种NoSQL的特性以及应用

# 8. 键值数据库

键值数据库是一张简单的哈希表，所有数据访问均通过主键来操作，值不一定有固定的数据结构

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908101347914.png" alt="image-20210908101347914" style="zoom:50%;" />

## 特性

仅仅支持耽搁键的操作的一致性；查询方面只支持关键字查询；数据结构支持几乎所有；可扩展性方面键值数据库可以用分片技术；

## 适用

在针对会话信息，用户配置信息，购物车数据的时候键值数据库会表现的很好

在处理数据间关系，处理含有多项操作的事务，查询数据，操纵关键字集合这些方面表现不好



# 9. 文档数据库

文档数据库可以实现在同一集合内的两个文档的数据模式不一样，文档数据库没有空属性，新增属性也很自由，无需预先定义。

下面两个文档是一个集合内的两个文档

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908111754303.png" alt="image-20210908111754303" style="zoom:50%;" />

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908111822757.png" alt="image-20210908111822757" style="zoom:50%;" />

## 特性

文档数据库可以直接查询文档中的数据，所以相对于键值数据库，它的效率更高，查询性能更接近关系型数据库

## 适用

文档数据库在事件记录，博客平台，电子商务应用程序方面表现出色（无特定模式的数据存储）

在需要跨文档的原子操作面前，文档数据库表现不好，另外如果需要经常查询持续改变格式的数据也不适合，因为这样查询语句需要经常改变



# 10. 列族数据库

列族数据库的概念通过hbase进行介绍

HBase存储的数据模型是一个四维模型，如图所示。

从图中可以看出，与关系型数据库中表的二维模型相比，HBase中的四维数据模型新增了列族和版本两个维度，从而形成了行键、列族、列和版本四维维度。由此可见，如果需要对数据库中的数据单元进行精确定位，就要使用四维坐标。

通过行键可以获取一个指定的行，它由一个或多个列族构成；每个列族有一个或多个列；每列有一个或多个版本。为了获取指定数据，就需要知道它的行键、列族、列限定符和版本。进行查询时，如果仅提供行键，会返回满足条件的整行数据；如果仅提供行键、列族和列限定符，会返回某行某列的最新单元值；如果再进一步增加时间戳，就会返回某行某列单元值的某个版本。

[![列族数据库HBase的四维模型-统计学之家](http://www.tjxzj.net/wp-content/uploads/2020/11/2020110206444192.jpg)](http://www.tjxzj.net/wp-content/uploads/2020/11/2020110206444192.jpg)

下面对HBase的四维模型中每个元素进行说明。

（1）行键（Row Key）：最大长度为64KB的任意字符串。与关系型数据库一样，行键是行的唯一标志。

（2）列族（Column Family）：这是理解列族数据库的关键概念。将数据行中的字段按照某种要求分成数个小组，每个小组包含若干个字段，每个小组就是列族。列族需要预先定义，并且不能随意修改。每行具有相同的列族，但不要求每个列族都存储数据。

（3）列限定符（Qualifier）：每个列族包含多个字段，限定符用于区分不同的字段。列限定符不需要预先定义，因此每行可以有不同数量的列限定符，也可以认为列限定符就是字段。

（4）单元（Cell）：存储数据的最小单元。单元中存储的是未经解释的字符串，需要通过行键、列族、列限定符、时间戳进行定位。

（5）版本（Version）：这是HBase与其他数据库的不同之处。版本是一个64位整型数，可以由系统自动生成，也可以由用户自定义。引入版本后，存储在单元中的值不再只有一个，可以通过不同的时间戳（Timestamp）在同一单元中存入多个版本。



## 特性

一般来说，写入操作在行级别是原子的，

## 适用性

hbase非常适合记录事件，可以将所有程序运行遇到的事件都记录下来，并使用（应用程序名：时间戳）作为行健

在开发早期不太适合这种数据库，因为无法确定查询模型，查询模式会导致列族的设计改变



# 11. 图数据库

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908213708677.png" alt="image-20210908213708677" style="zoom:50%;" />

图数据库遍历的速度非常快，图数据库的增加很容易，但是更改目前的节点很困难，相当于数据迁移

## 特性

一般来说不支持多节点，且不允许出现悬挂关系

图数据库不是面向聚合的，而是面向关系的，所以普通的分片不可用，一般来说可以增加只读的副本，或者可以使用特定的分片，例如

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210908215218584.png" alt="image-20210908215218584" style="zoom:50%;" />

## 适用

互联数据（社交网络），运输路线（基于位置的），推荐引擎较为适用图数据库

在频繁更新实体的情况下，这种数据库也不适用，因为操作复杂



# 12. 模式迁移

若要迁移关系型数据库等“强模式”数据库，可以将数据迁移操作保存为：版本控制序列



# 13. 混合持久化

根据需要存储的数据需求不同，需要的数据库也不一样，举例来说

保存事务数据，缓存会话信息，遍历客户图找出友人关系，这三种需求面临的问题不同，所以应该分别使用不同的数据存储方法

<img src="/Users/lizhihan/Library/Application Support/typora-user-images/image-20210909091702160.png" alt="image-20210909091702160" style="zoom:33%;" />

不同数据库的设计目标不同，并非所有问题都能用一种数据库优雅的解决

将数据库封装成服务可以减少数据库变动对系统其它部分的影响

新增数据库技术会让编程变得复杂，所以要权衡带来的好处和引入的复杂度

